# -*- coding: utf-8 -*-
"""v_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jw3IvmuhVcfcj0BS8xIUBzyqPSFT8tqi
"""

import streamlit as st
import numpy as np
import joblib
import os
import pandas as pd
import re

# Set page title and layout
st.set_page_config(
    page_title="RTL Logic Depth Predictor",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Check if model files exist
MODEL_PATH = "optimized_mlp_model.pkl"
SCALER_PATH = "scaler.pkl"

# Helper function to load models
def load_model_and_scaler():
    if not os.path.exists(MODEL_PATH):
        return None, None, f"Model file not found: {MODEL_PATH}"
    if not os.path.exists(SCALER_PATH):
        return None, None, f"Scaler file not found: {SCALER_PATH}"

    try:
        model = joblib.load(MODEL_PATH)
        scaler = joblib.load(SCALER_PATH)
        return model, scaler, None
    except Exception as e:
        return None, None, f"Error loading model: {str(e)}"

# Load model at startup
model, scaler, error_message = load_model_and_scaler()

# App title and description
st.title("RTL Logic Depth Predictor")
st.markdown("""
This tool predicts the combinational logic depth of signals in behavioral RTL
without waiting for synthesis, accelerating the design cycle.
""")

# Show error if model files missing
if error_message:
    st.error(error_message)

# Create sidebar for additional info
with st.sidebar:
    st.header("About")
    st.markdown("""
    ### Timing Analysis Acceleration

    Timing analysis is a crucial step in the design of any complex IP/SoC. However, timing analysis
    reports are generated after synthesis is complete, which is very time-consuming.

    This AI algorithm predicts combinational logic depth of signals in behavioral RTL,
    helping to identify potential timing issues early in the design process.
    """)

    st.header("How to Use")
    st.markdown("""
    1. **Enter Verilog Code**: Paste your Verilog module in the text area
    2. **Click Analyze**: The tool will extract features and predict logic depth
    3. **Review Results**: See the predicted logic depth and recommendations

    You can also use the manual mode to enter circuit parameters directly.
    """)

# Create tabs for different input methods
tab1, tab2 = st.tabs(["Verilog Input", "Manual Parameters"])

# Define function to extract features from Verilog
def extract_features_from_verilog(verilog_code):
    try:
        # Extract input ports
        input_pattern = r'input\s+(?:wire\s+)?(?:\[[^\]]+\]\s+)?([^;]+);'
        input_matches = re.findall(input_pattern, verilog_code)

        # Clean and split input port names
        inputs = []
        for match in input_matches:
            ports = match.replace('\n', '').replace(' ', '').split(',')
            inputs.extend(ports)

        # Extract output ports
        output_pattern = r'output\s+(?:wire\s+|reg\s+)?(?:\[[^\]]+\]\s+)?([^;]+);'
        output_matches = re.findall(output_pattern, verilog_code)

        # Clean and split output port names
        outputs = []
        for match in output_matches:
            ports = match.replace('\n', '').replace(' ', '').split(',')
            outputs.extend(ports)

        fan_in = len(inputs)
        fan_out = len(outputs)

        # Count gate types
        gate_types = {
            'and': len(re.findall(r'&(?!=)', verilog_code)),
            'or': len(re.findall(r'\|(?!=)', verilog_code)),
            'xor': len(re.findall(r'\^(?!=)', verilog_code)),
            'not': len(re.findall(r'~', verilog_code)),
            'nand': len(re.findall(r'~\s*\(.*&', verilog_code)),
            'nor': len(re.findall(r'~\s*\(.*\|', verilog_code)),
        }

        # Count always blocks as a complexity indicator
        always_blocks = len(re.findall(r'always\s*@', verilog_code))

        # Count if-else statements
        if_statements = len(re.findall(r'if\s*\(', verilog_code))

        # Count case statements
        case_statements = len(re.findall(r'case\s*\(', verilog_code))

        # Count ternary operators
        ternary_ops = len(re.findall(r'\?', verilog_code))

        # Calculate total gate count (approximation)
        gate_count = sum(gate_types.values()) + if_statements + case_statements + ternary_ops

        # If no gates detected but code exists, make minimum assumption
        if gate_count == 0 and len(verilog_code.strip()) > 0:
            gate_count = max(1, fan_in // 2)

        # Calculate gate diversity (0-1)
        non_zero_gates = sum(1 for count in gate_types.values() if count > 0)
        gate_diversity = non_zero_gates / max(1, len(gate_types))

        # Estimate complexity score (0-10)
        complexity_base = 2 + (always_blocks * 1.5) + (if_statements * 0.5) + (case_statements * 0.8)
        complexity_score = min(10, complexity_base + (gate_count / 20))

        # Calculate entropy based on gate distribution
        total_gates = max(1, sum(gate_types.values()))
        probabilities = [count/total_gates for count in gate_types.values() if count > 0]

        if probabilities:
            entropy_score = -sum(p * np.log2(p) for p in probabilities) / np.log2(len(probabilities))
        else:
            entropy_score = 0.5  # Default when no clear gate pattern

        features = {
            'fan_in': fan_in,
            'fan_out': fan_out,
            'gate_count': gate_count,
            'gate_diversity': gate_diversity,
            'complexity_score': complexity_score,
            'entropy_score': entropy_score
        }

        return features, None

    except Exception as e:
        return None, f"Error extracting features: {str(e)}"
def predict_logic_depth(fan_in, fan_out, gate_count, gate_diversity, complexity_score, entropy_score):
    if model is None or scaler is None:
        return None, "Model or scaler not loaded correctly"

    try:
        # Create input array with derived features
        ratio_fan = fan_in / max(1, fan_out)  # Prevent division by zero
        ratio_gate = gate_count / max(1, fan_in)

        features = np.array([[
            fan_in, fan_out, gate_count,
            ratio_fan, ratio_gate,
            gate_diversity, complexity_score, entropy_score
        ]])

        # Scale features
        features_scaled = scaler.transform(features)

        # Make prediction and convert to integer (logic depth must be an integer)
        raw_prediction = model.predict(features_scaled)[0]

        # Round to nearest integer for logic depth
        prediction = int(round(raw_prediction))

        # Ensure prediction is at least 1 (minimum possible depth)
        prediction = max(1, prediction)

        return prediction, None
    except Exception as e:
        return None, f"Prediction error: {str(e)}"

# Verilog Input Tab
with tab1:
    st.header("Enter Verilog Code")

    # Example code button
    if st.button("Load Example Verilog"):
        example_verilog = """module alu (
    input [7:0] A, B,
    input [2:0] opcode,
    output reg [7:0] result,
    output zero_flag
);

    always @(*) begin
        case (opcode)
            3'b000: result = A + B;           // ADD
            3'b001: result = A - B;           // SUB
            3'b010: result = A & B;           // AND
            3'b011: result = A | B;           // OR
            3'b100: result = A ^ B;           // XOR
            3'b101: result = ~A;              // NOT
            3'b110: result = A << 1;          // Left shift
            3'b111: result = A >> 1;          // Right shift
            default: result = 8'b0;
        endcase
    end

    assign zero_flag = (result == 8'b0) ? 1'b1 : 1'b0;

endmodule"""
        st.session_state.verilog_code = example_verilog

    # Text area for Verilog code
    verilog_code = st.text_area("Paste your Verilog code here:",
                               value=st.session_state.get('verilog_code', ''),
                               height=300)
    st.session_state.verilog_code = verilog_code

    # Analyze button
    if st.button("Analyze Verilog", type="primary"):
        if not verilog_code.strip():
            st.error("Please enter Verilog code")
        else:
            with st.spinner("Analyzing code..."):
                # Extract features from Verilog
                features, error = extract_features_from_verilog(verilog_code)

                if error:
                    st.error(error)
                else:
                    # Display extracted features
                    st.subheader("Extracted Features")
                    col1, col2 = st.columns(2)

                    with col1:
                        st.metric("Fan-In (Inputs)", features['fan_in'])
                        st.metric("Fan-Out (Outputs)", features['fan_out'])
                        st.metric("Estimated Gate Count", features['gate_count'])

                    with col2:
                        st.metric("Gate Diversity", f"{features['gate_diversity']:.2f}")
                        st.metric("Complexity Score", f"{features['complexity_score']:.2f}")
                        st.metric("Entropy Score", f"{features['entropy_score']:.2f}")

                    # Make prediction
                    prediction, pred_error = predict_logic_depth(
                        features['fan_in'],
                        features['fan_out'],
                        features['gate_count'],
                        features['gate_diversity'],
                        features['complexity_score'],
                        features['entropy_score']
                    )

                    if pred_error:
                        st.error(pred_error)
                    else:
                        # Display prediction
                        st.subheader("Prediction Results")
                        col1, col2 = st.columns([1, 1])

                        with col1:
                            st.metric("Predicted Logic Depth", prediction)

                            # Add technical explanation
                            st.markdown(f"""
                            **Technical Details:**
                            - A logic depth of {prediction} means signals must pass through {prediction} sequential gates
                            
                            """)

                        with col2:
                            # Create a simple visualization of the logic depth
                            st.markdown("### Visual Representation")
                            max_depth = 20
                            progress = min(1.0, prediction / max_depth)
                            st.progress(progress)

                            if prediction <= 4:
                                st.info("✅ Low logic depth: Likely to meet timing constraints")
                            elif prediction <= 8:
                                st.warning("⚠️ Medium logic depth: May require optimization")
                            else:
                                st.error("🛑 High logic depth: Likely timing violations")

                            # Show recommendations
                            st.markdown("### Recommendations")
                            if prediction <= 4:
                                st.markdown("- Design looks good for timing closure")
                                st.markdown("- Proceed with synthesis")
                            elif prediction <= 8:
                                st.markdown("- Consider parallel logic structures")
                                st.markdown("- Review Boolean equations for simplification")
                            else:
                                st.markdown("- Consider design refactoring")
                                st.markdown("- Break down into pipeline stages")
                                st.markdown("- Evaluate using faster cell libraries")

# Manual Parameters Tab
with tab2:
    st.header("Enter Circuit Parameters Manually")

    # Add a section for example presets
    st.subheader("Example Circuits")
    example = st.selectbox(
        "Select a pre-configured example",
        options=["Custom (use values below)", "Small Circuit", "Medium Circuit", "Complex Circuit"]
    )

    # Initialize session state if not already done
    if 'initialized' not in st.session_state:
        st.session_state.initialized = True
        st.session_state.fan_in = 8
        st.session_state.fan_out = 4
        st.session_state.gate_count = 20
        st.session_state.gate_diversity = 0.7
        st.session_state.complexity_score = 5.5
        st.session_state.entropy_score = 0.6

    # Update values based on example selection
    if example == "Small Circuit" and st.session_state.get('last_example') != "Small Circuit":
        st.session_state.fan_in = 8
        st.session_state.fan_out = 2
        st.session_state.gate_count = 16
        st.session_state.gate_diversity = 0.5
        st.session_state.complexity_score = 4.0
        st.session_state.entropy_score = 0.4
        st.session_state.last_example = "Small Circuit"
        st.rerun()
    elif example == "Medium Circuit" and st.session_state.get('last_example') != "Medium Circuit":
        st.session_state.fan_in = 12
        st.session_state.fan_out = 4
        st.session_state.gate_count = 30
        st.session_state.gate_diversity = 0.8
        st.session_state.complexity_score = 6.2
        st.session_state.entropy_score = 0.7
        st.session_state.last_example = "Medium Circuit"
        st.rerun()
    elif example == "Complex Circuit" and st.session_state.get('last_example') != "Complex Circuit":
        st.session_state.fan_in = 24
        st.session_state.fan_out = 8
        st.session_state.gate_count = 60
        st.session_state.gate_diversity = 0.9
        st.session_state.complexity_score = 8.5
        st.session_state.entropy_score = 0.8
        st.session_state.last_example = "Complex Circuit"
        st.rerun()
    elif example == "Custom (use values above)" and st.session_state.get('last_example') != "Custom (use values above)":
        st.session_state.last_example = "Custom (use values above)"

    # Create two columns for inputs
    col1, col2 = st.columns(2)

    with col1:
        fan_in = st.number_input("Fan-In (Number of inputs)",
                                min_value=1,
                                value=st.session_state.fan_in)
        fan_out = st.number_input("Fan-Out (Number of outputs)",
                                min_value=1,
                                value=st.session_state.fan_out)
        gate_count = st.number_input("Gate Count (Total gates in design)",
                                    min_value=1,
                                    value=st.session_state.gate_count)

    with col2:
        gate_diversity = st.slider("Gate Diversity Score",
                                min_value=0.0,
                                max_value=1.0,
                                value=st.session_state.gate_diversity,
                                step=0.1)
        complexity_score = st.slider("Boolean Complexity Score",
                                    min_value=0.0,
                                    max_value=10.0,
                                    value=st.session_state.complexity_score,
                                    step=0.1)
        entropy_score = st.slider("Entropy of Gate Types",
                                min_value=0.0,
                                max_value=1.0,
                                value=st.session_state.entropy_score,
                                step=0.1)

    # Save current values to session state
    st.session_state.fan_in = fan_in
    st.session_state.fan_out = fan_out
    st.session_state.gate_count = gate_count
    st.session_state.gate_diversity = gate_diversity
    st.session_state.complexity_score = complexity_score
    st.session_state.entropy_score = entropy_score

    # Create prediction button
    if st.button("Predict Logic Depth", key="manual_predict", type="primary"):
        with st.spinner("Calculating..."):
            prediction, error = predict_logic_depth(
                fan_in, fan_out, gate_count, gate_diversity, complexity_score, entropy_score
            )

        if error:
            st.error(error)
        else:
            # Success - show result with visualization
            st.success(f"Prediction complete!")

            col1, col2 = st.columns([1, 1])

            with col1:
                st.metric("Predicted Logic Depth", prediction)

                # Add technical explanation
                st.markdown(f"""
                **Technical Details:**
                - A logic depth of {prediction} means signals must pass through {prediction} sequential gates
                
                """)

            with col2:
                # Create a simple visualization of the logic depth
                st.markdown("### Visual Representation")
                max_depth = 20  # Adjust based on your model's typical output range
                progress = min(1.0, prediction / max_depth)
                st.progress(progress)

                if prediction <= 4:
                    st.info("✅ Low logic depth: Likely to meet timing constraints")
                elif prediction <= 8:
                    st.warning("⚠️ Medium logic depth: May require optimization")
                else:
                    st.error("🛑 High logic depth: Likely timing violations")

                # Show recommendations based on logic depth
                st.markdown("### Recommendations")
                if prediction <= 4:
                    st.markdown("- Design looks good for timing closure")
                    st.markdown("- Proceed with synthesis")
                elif prediction <= 8:
                    st.markdown("- Consider parallel logic structures")
                    st.markdown("- Review Boolean equations for simplification")
                else:
                    st.markdown("- Consider design refactoring")
                    st.markdown("- Break down into pipeline stages")
                    st.markdown("- Evaluate using faster cell libraries")

# Prediction function (needs to be defined before it's called)
